"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextRolloutId = exports.ensureApiEnabled = exports.listLocations = exports.updateTraffic = exports.listRollouts = exports.createRollout = exports.createBuild = exports.listBuilds = exports.getBuild = exports.deleteBackend = exports.listBackends = exports.getBackend = exports.createBackend = exports.client = exports.API_VERSION = void 0;
const proto = require("../gcp/proto");
const apiv2_1 = require("../apiv2");
const projectUtils_1 = require("../projectUtils");
const api_1 = require("../api");
const ensureApiEnabled_1 = require("../ensureApiEnabled");
const deploymentTool = require("../deploymentTool");
const error_1 = require("../error");
const metaprogramming_1 = require("../metaprogramming");
exports.API_VERSION = "v1alpha";
exports.client = new apiv2_1.Client({
    urlPrefix: api_1.apphostingOrigin,
    auth: true,
    apiVersion: exports.API_VERSION,
});
(0, metaprogramming_1.assertImplements)();
(0, metaprogramming_1.assertImplements)();
(0, metaprogramming_1.assertImplements)();
(0, metaprogramming_1.assertImplements)();
async function createBackend(projectId, location, backendReqBoby, backendId) {
    const res = await exports.client.post(`projects/${projectId}/locations/${location}/backends`, Object.assign(Object.assign({}, backendReqBoby), { labels: Object.assign(Object.assign({}, backendReqBoby.labels), deploymentTool.labels()) }), { queryParams: { backendId } });
    return res.body;
}
exports.createBackend = createBackend;
async function getBackend(projectId, location, backendId) {
    const name = `projects/${projectId}/locations/${location}/backends/${backendId}`;
    const res = await exports.client.get(name);
    return res.body;
}
exports.getBackend = getBackend;
async function listBackends(projectId, location) {
    const name = `projects/${projectId}/locations/${location}/backends`;
    const res = await exports.client.get(name);
    return res.body;
}
exports.listBackends = listBackends;
async function deleteBackend(projectId, location, backendId) {
    const name = `projects/${projectId}/locations/${location}/backends/${backendId}`;
    const res = await exports.client.delete(name, { queryParams: { force: "true" } });
    return res.body;
}
exports.deleteBackend = deleteBackend;
async function getBuild(projectId, location, backendId, buildId) {
    const name = `projects/${projectId}/locations/${location}/backends/${backendId}/builds/${buildId}`;
    const res = await exports.client.get(name);
    return res.body;
}
exports.getBuild = getBuild;
async function listBuilds(projectId, location, backendId) {
    var _a;
    const name = `projects/${projectId}/locations/${location}/backends/${backendId}/builds`;
    let pageToken;
    const res = {
        builds: [],
        unreachable: [],
    };
    do {
        const queryParams = pageToken ? { pageToken } : {};
        const int = await exports.client.get(name, { queryParams });
        res.builds.push(...(int.body.builds || []));
        (_a = res.unreachable) === null || _a === void 0 ? void 0 : _a.push(...(int.body.unreachable || []));
        pageToken = int.body.nextPageToken;
    } while (pageToken);
    res.unreachable = [...new Set(res.unreachable)];
    return res;
}
exports.listBuilds = listBuilds;
async function createBuild(projectId, location, backendId, buildId, buildInput) {
    const res = await exports.client.post(`projects/${projectId}/locations/${location}/backends/${backendId}/builds`, Object.assign(Object.assign({}, buildInput), { labels: Object.assign(Object.assign({}, buildInput.labels), deploymentTool.labels()) }), { queryParams: { buildId } });
    return res.body;
}
exports.createBuild = createBuild;
async function createRollout(projectId, location, backendId, rolloutId, rollout, validateOnly = false) {
    const res = await exports.client.post(`projects/${projectId}/locations/${location}/backends/${backendId}/rollouts`, Object.assign(Object.assign({}, rollout), { labels: Object.assign(Object.assign({}, rollout.labels), deploymentTool.labels()) }), { queryParams: { rolloutId, validateOnly: validateOnly ? "true" : "false" } });
    return res.body;
}
exports.createRollout = createRollout;
async function listRollouts(projectId, location, backendId) {
    const name = `projects/${projectId}/locations/${location}/backends/${backendId}/rollouts`;
    let pageToken = undefined;
    const res = {
        rollouts: [],
        unreachable: [],
    };
    do {
        const queryParams = pageToken ? { pageToken } : {};
        const int = await exports.client.get(name, { queryParams });
        res.rollouts.splice(res.rollouts.length, 0, ...(int.body.rollouts || []));
        res.unreachable.splice(res.unreachable.length, 0, ...(int.body.unreachable || []));
        pageToken = int.body.nextPageToken;
    } while (pageToken);
    res.unreachable = [...new Set(res.unreachable)];
    return res;
}
exports.listRollouts = listRollouts;
async function updateTraffic(projectId, location, backendId, traffic) {
    const fieldMasks = proto.fieldMasks(traffic, "rolloutPolicy");
    const queryParams = {
        updateMask: fieldMasks.join(","),
    };
    const name = `projects/${projectId}/locations/${location}/backends/${backendId}/traffic`;
    const res = await exports.client.patch(name, Object.assign(Object.assign({}, traffic), { name }), {
        queryParams,
    });
    return res.body;
}
exports.updateTraffic = updateTraffic;
async function listLocations(projectId) {
    let pageToken = undefined;
    let locations = [];
    do {
        const queryParams = pageToken ? { pageToken } : {};
        const response = await exports.client.get(`projects/${projectId}/locations`, {
            queryParams,
        });
        if (response.body.locations && response.body.locations.length > 0) {
            locations = locations.concat(response.body.locations);
        }
        pageToken = response.body.nextPageToken;
    } while (pageToken);
    return locations;
}
exports.listLocations = listLocations;
async function ensureApiEnabled(options) {
    const projectId = (0, projectUtils_1.needProjectId)(options);
    return await (0, ensureApiEnabled_1.ensure)(projectId, api_1.apphostingOrigin, "app hosting", true);
}
exports.ensureApiEnabled = ensureApiEnabled;
async function getNextRolloutId(projectId, location, backendId, counter) {
    var _a;
    const date = new Date();
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, "0");
    const day = String(date.getUTCDate()).padStart(2, "0");
    if (counter) {
        return `build-${year}-${month}-${day}-${String(counter).padStart(3, "0")}`;
    }
    const builds = await exports.listRollouts(projectId, location, backendId);
    if ((_a = builds.unreachable) === null || _a === void 0 ? void 0 : _a.includes(location)) {
        throw new error_1.FirebaseError(`Firebase App Hosting is currently unreachable in location ${location}`);
    }
    let highest = 0;
    const test = new RegExp(`projects/${projectId}/locations/${location}/backends/${backendId}/rollouts/build-${year}-${month}-${day}-(\\d+)`);
    for (const rollout of builds.rollouts) {
        const match = rollout.name.match(test);
        if (!match) {
            continue;
        }
        const n = Number(match[1]);
        if (n > highest) {
            highest = n;
        }
    }
    return `build-${year}-${month}-${day}-${String(highest + 1).padStart(3, "0")}`;
}
exports.getNextRolloutId = getNextRolloutId;
