"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orchestrateRollout = exports.setDefaultTrafficPolicy = exports.createBackend = exports.doSetup = void 0;
const clc = require("colorette");
const repo = require("./repo");
const poller = require("../../../operation-poller");
const apphosting = require("../../../gcp/apphosting");
const utils_1 = require("../../../utils");
const api_1 = require("../../../api");
const apphosting_1 = require("../../../gcp/apphosting");
const resourceManager_1 = require("../../../gcp/resourceManager");
const iam_1 = require("../../../gcp/iam");
const error_1 = require("../../../error");
const prompt_1 = require("../../../prompt");
const constants_1 = require("./constants");
const ensureApiEnabled_1 = require("../../../ensureApiEnabled");
const deploymentTool = require("../../../deploymentTool");
const DEFAULT_COMPUTE_SERVICE_ACCOUNT_NAME = "firebase-app-hosting-compute";
const apphostingPollerOptions = {
    apiOrigin: api_1.apphostingOrigin,
    apiVersion: apphosting_1.API_VERSION,
    masterTimeout: 25 * 60 * 1000,
    maxBackoff: 10000,
};
async function doSetup(projectId, location, serviceAccount) {
    await Promise.all([
        (0, ensureApiEnabled_1.ensure)(projectId, api_1.cloudbuildOrigin, "apphosting", true),
        (0, ensureApiEnabled_1.ensure)(projectId, api_1.secretManagerOrigin, "apphosting", true),
        (0, ensureApiEnabled_1.ensure)(projectId, api_1.cloudRunApiOrigin, "apphosting", true),
        (0, ensureApiEnabled_1.ensure)(projectId, api_1.artifactRegistryDomain, "apphosting", true),
    ]);
    const allowedLocations = (await apphosting.listLocations(projectId)).map((loc) => loc.locationId);
    if (location) {
        if (!allowedLocations.includes(location)) {
            throw new error_1.FirebaseError(`Invalid location ${location}. Valid choices are ${allowedLocations.join(", ")}`);
        }
    }
    (0, utils_1.logBullet)("First we need a few details to create your backend.");
    location =
        location ||
            (await (0, prompt_1.promptOnce)({
                name: "region",
                type: "list",
                default: constants_1.DEFAULT_REGION,
                message: "Please select a region " +
                    `(${clc.yellow("info")}: Your region determines where your backend is located):\n`,
                choices: allowedLocations.map((loc) => ({ value: loc })),
            }));
    (0, utils_1.logSuccess)(`Region set to ${location}.\n`);
    const backendId = await promptNewBackendId(projectId, location, {
        name: "backendId",
        type: "input",
        default: "my-web-app",
        message: "Create a name for your backend [1-30 characters]",
    });
    const cloudBuildConnRepo = await repo.linkGitHubRepository(projectId, location);
    const backend = await createBackend(projectId, location, backendId, cloudBuildConnRepo, serviceAccount);
    const branch = await (0, prompt_1.promptOnce)({
        name: "branch",
        type: "input",
        default: "main",
        message: "Pick a branch for continuous deployment",
    });
    await setDefaultTrafficPolicy(projectId, location, backendId, branch);
    const confirmRollout = await (0, prompt_1.promptOnce)({
        type: "confirm",
        name: "rollout",
        default: true,
        message: "Do you want to deploy now?",
    });
    if (!confirmRollout) {
        (0, utils_1.logSuccess)(`Successfully created backend:\n\t${backend.name}`);
        (0, utils_1.logSuccess)(`Your site will be deployed at:\n\thttps://${backend.uri}`);
        return;
    }
    await orchestrateRollout(projectId, location, backendId, {
        source: {
            codebase: {
                branch,
            },
        },
    });
    (0, utils_1.logSuccess)(`Successfully created backend:\n\t${backend.name}`);
    (0, utils_1.logSuccess)(`Your site is now deployed at:\n\thttps://${backend.uri}`);
}
exports.doSetup = doSetup;
async function promptNewBackendId(projectId, location, prompt) {
    while (true) {
        const backendId = await (0, prompt_1.promptOnce)(prompt);
        try {
            await apphosting.getBackend(projectId, location, backendId);
        }
        catch (err) {
            if (err.status === 404) {
                return backendId;
            }
            throw new error_1.FirebaseError(`Failed to check if backend with id ${backendId} already exists in ${location}`, { original: err });
        }
        (0, utils_1.logWarning)(`Backend with id ${backendId} already exists in ${location}`);
    }
}
function defaultComputeServiceAccountEmail(projectId) {
    return `${DEFAULT_COMPUTE_SERVICE_ACCOUNT_NAME}@${projectId}.iam.gserviceaccount.com`;
}
async function createBackend(projectId, location, backendId, repository, serviceAccount) {
    const defaultServiceAccount = defaultComputeServiceAccountEmail(projectId);
    const backendReqBody = {
        servingLocality: "GLOBAL_ACCESS",
        codebase: {
            repository: `${repository.name}`,
            rootDirectory: "/",
        },
        labels: deploymentTool.labels(),
        computeServiceAccount: serviceAccount || defaultServiceAccount,
    };
    delete backendReqBody.computeServiceAccount;
    async function createBackendAndPoll() {
        const op = await apphosting.createBackend(projectId, location, backendReqBody, backendId);
        return await poller.pollOperation(Object.assign(Object.assign({}, apphostingPollerOptions), { pollerName: `create-${projectId}-${location}-${backendId}`, operationResourceName: op.name }));
    }
    try {
        return await createBackendAndPoll();
    }
    catch (err) {
        if (err.status === 403) {
            if (err.message.includes(defaultServiceAccount)) {
                await provisionDefaultComputeServiceAccount(projectId);
                return await createBackendAndPoll();
            }
            else if (serviceAccount && err.message.includes(serviceAccount)) {
                throw new error_1.FirebaseError(`Failed to create backend due to missing delegation permissions for ${serviceAccount}. Make sure you have the iam.serviceAccounts.actAs permission.`, { children: [err] });
            }
        }
        throw err;
    }
}
exports.createBackend = createBackend;
async function provisionDefaultComputeServiceAccount(projectId) {
    try {
        await (0, iam_1.createServiceAccount)(projectId, DEFAULT_COMPUTE_SERVICE_ACCOUNT_NAME, "Firebase App Hosting compute service account", "Default service account used to run builds and deploys for Firebase App Hosting");
    }
    catch (err) {
        if (err.status !== 409) {
            throw err;
        }
    }
    await (0, resourceManager_1.addServiceAccountToRoles)(projectId, defaultComputeServiceAccountEmail(projectId), [
        "roles/firebaseapphosting.viewer",
        "roles/artifactregistry.createOnPushWriter",
        "roles/logging.logWriter",
        "roles/storage.objectAdmin",
        "roles/firebase.sdkAdminServiceAgent",
    ], true);
}
async function setDefaultTrafficPolicy(projectId, location, backendId, codebaseBranch) {
    const traffic = {
        rolloutPolicy: {
            codebaseBranch: codebaseBranch,
            stages: [
                {
                    progression: "IMMEDIATE",
                    targetPercent: 100,
                },
            ],
        },
    };
    const op = await apphosting.updateTraffic(projectId, location, backendId, traffic);
    await poller.pollOperation(Object.assign(Object.assign({}, apphostingPollerOptions), { pollerName: `updateTraffic-${projectId}-${location}-${backendId}`, operationResourceName: op.name }));
}
exports.setDefaultTrafficPolicy = setDefaultTrafficPolicy;
async function orchestrateRollout(projectId, location, backendId, buildInput) {
    (0, utils_1.logBullet)("Starting a new rollout... this may take a few minutes.");
    const buildId = await apphosting.getNextRolloutId(projectId, location, backendId, 1);
    const buildOp = await apphosting.createBuild(projectId, location, backendId, buildId, buildInput);
    const rolloutBody = {
        build: `projects/${projectId}/locations/${location}/backends/${backendId}/builds/${buildId}`,
    };
    let tries = 0;
    let done = false;
    while (!done) {
        tries++;
        try {
            const validateOnly = true;
            await apphosting.createRollout(projectId, location, backendId, buildId, rolloutBody, validateOnly);
            done = true;
        }
        catch (err) {
            if (err instanceof error_1.FirebaseError && err.status === 400) {
                if (tries >= 5) {
                    throw err;
                }
                await new Promise((resolve) => setTimeout(resolve, 1000));
            }
            else {
                throw err;
            }
        }
    }
    const rolloutOp = await apphosting.createRollout(projectId, location, backendId, buildId, rolloutBody);
    const rolloutPoll = poller.pollOperation(Object.assign(Object.assign({}, apphostingPollerOptions), { pollerName: `create-${projectId}-${location}-backend-${backendId}-rollout-${buildId}`, operationResourceName: rolloutOp.name }));
    const buildPoll = poller.pollOperation(Object.assign(Object.assign({}, apphostingPollerOptions), { pollerName: `create-${projectId}-${location}-backend-${backendId}-build-${buildId}`, operationResourceName: buildOp.name }));
    const [rollout, build] = await Promise.all([rolloutPoll, buildPoll]);
    (0, utils_1.logSuccess)("Rollout completed.");
    if (build.state !== "READY") {
        if (!build.buildLogsUri) {
            throw new error_1.FirebaseError("Failed to build your app, but failed to get build logs as well. " +
                "This is an internal error and should be reported");
        }
        throw new error_1.FirebaseError(`Failed to build your app. Please inspect the build logs at ${build.buildLogsUri}.`, { children: [build.error] });
    }
    return { rollout, build };
}
exports.orchestrateRollout = orchestrateRollout;
